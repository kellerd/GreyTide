/// <reference path="../../scripts/typings/angularjs/angular.d.ts" />
/// <reference path="../../scripts/typings/statemachine/statemachine.d.ts" />
/// <reference path="../../scripts/typings/breeze/breeze.d.ts" />
module App.Services {

    export interface IDatacontext {
        getTideAndState(): ng.IPromise<ITideAndState>;
        getTide(): ng.IPromise<any>;
        getStates(): ng.IPromise<any>;
        prime(): Function;
        create(localModelName: string, initialValues?: {}, entityState?: breeze.EntityStateSymbol, mergeStrategy?: breeze.MergeStrategySymbol) : breeze.Entity
    }

    export interface ITideAndState {
        states: any;
        tide: any;
    }

    export class Datacontext {
        public static serviceId: string = 'datacontext';
        private $q: ng.IQService;

        private getLogFn: (moduleId: string, fnName?: string)=>any;
        private logError: (message: string, data?: any, source?: string, showToast?: boolean) => void;
        private logSuccess: (message: string, data?: any, source?: string, showToast?: boolean) => void;
        private log: (message: string, data?: any, source?: string, showToast?: boolean) => void;
        private EntityQuery: typeof breeze.EntityQuery;
        private manager: IManagerAndMetaModels;

        constructor(private common: App.Shared.ICommon, entityManagerFactory: IEntityManagerFactory, private config:IConfigurations) {
            this.$q = common.$q;
            this.log = common.logger.log;
            this.logError = common.logger.logError;
            this.logSuccess = common.logger.logSuccess;
            this.EntityQuery = breeze.EntityQuery;
            this.manager = entityManagerFactory.newManager();
        }
        create(localModelName: string, initialValues?: {}, entityState?: breeze.EntityStateSymbol, mergeStrategy?: breeze.MergeStrategySymbol): breeze.Entity {
            return this.manager.manager.createEntity(localModelName, initialValues, entityState, mergeStrategy);
        }

        public getTide(): ng.IPromise<any> {
            var tide;

            var getSucceeded = (data) => {
                tide = data.results;
                this.log("Retrieved [Tide] from remote data source", tide.length, null, true);
                return tide;
            }
            return this.EntityQuery.from("Tide").expand("states,items")
                .using(this.manager.manager).execute()
                .then(getSucceeded)
                .catch(this.getFailed);

        }

        private getFailed = (error) => {
            var msg = this.config.appErrorPrefix + "Error retrieving states: " + error.message;
            this.logError(msg, error);
            throw error;
        }

        public getStates(): ng.IPromise<any> {
            var states;

            var getSucceeded = (data) => {
                states = data.results;
                this.log("Retrieved [States] from remote data source", states.length, null, true);
                return states;
            }
            return this.EntityQuery.from("States").expand("events.from")
                .using(this.manager.manager).execute()
                .then(getSucceeded)
                .catch(this.getFailed);

        }
        public getTideAndState(): ng.IPromise<ITideAndState> {
            return this.$q.all([this.getStates(), this.getTide()]).then( (dataArray) => {
                return <ITideAndState>{ states: dataArray[0], tide: dataArray[1] };
            });
        }
        public prime():void {
            this.getStates().then((data) => {
                var events = data[0].events.map((e) => {
                    return {
                        name: e.name,
                        from: e.from.map(function (f) { return f.name; }),
                        to: e.to
                    }
                });
                StateMachine.create({
                    target: this.manager.Model.prototype,
                    initial: { state: 'None', event: 'init', defer: true },
                    events: events
                });
                this.log("States primed");
            }, (error) => {
                this.logError(error,null,Datacontext.serviceId,true);
            });
        }
    }

    // Register with angular
    app.factory(Datacontext.serviceId, ['common', 'entityManagerFactory', 'config', (common, entityManagerFactory, config) => new Datacontext(common, entityManagerFactory, config)]);

}
'use strict';
module App {
    export class MetadataHelper {
        public fillMetadataStore(store) {

            // Metadata-Helper instance configured with default namespace and key generator for this model
            var helper = new breeze.config.MetadataHelper('CC.Model', breeze.AutoGeneratedKeyType.Identity);
            // DataTypes
            var DT = breeze.DataType;
            var BOOL = DT.Boolean;
            var DATE = DT.DateTime;
            var ID = DT.Int32;
            var GUID = DT.Guid;
            var STRING = DT.String;

            // type order is irrelevant
            addModel();
            // addType - make it easy to add the type to the store using the helper
            function addType(type) {
                helper.addTypeToStore(store, type);
            };

            function addModel() {
                addType({
                    name: 'Model',
                    dataProperties: {
                        UserToken: { type: GUID, required: true },
                        Id: { type: GUID, required: true },
                        Name: { type: STRING, required: true },
                        CurrentState: { type: STRING },
                        CurrentDate: { type: DATE },
                        Faction: { type: STRING },
                        Points: { type: ID },
                        ParentId: { type: GUID }
                    },
                    navigationProperties {
                        Items: { type: 'Model', hasMany: true },
                        States: { type: 'ModelState', hasMany: true },
                        Parent: { type: 'Model', hasMany: false }
                    }

                });
            }

            //function addPerson() {
            //    addType({
            //        name: 'Person',
            //        dataProperties: {
            //            id: { type: ID },
            //            firstName: { max: 50, required: true },
            //            lastName: { max: 50, required: true },
            //            // could add validators here; let model.validation add them
            //            email: { max: 400 },
            //            blog: { max: 400 },
            //            twitter: { max: 400 },
            //            gender: { max: 1 },
            //            imageSource: { max: 400 },

            //            // could let Breeze add unmapped but we do so to lock in the Boolean data type
            //            isPartial: { type: BOOL, required: true, isUnmapped: true },
            //            isSpeaker: { type: BOOL, required: true, isUnmapped: true }
            //        },

            //        navigationProperties: {
            //            speakerSessions: { type: 'Session', hasMany: true }
            //        }
            //    });
            //}

            //function addSession() {
            //    addType({
            //        name: 'Session',
            //        dataProperties: {
            //            id: { type: ID },
            //            title: { max: 50, required: true },
            //            code: { max: 10 },
            //            description: { max: 4000 },
            //            level: { max: 30 },
            //            tags: { max: 4000 },

            //            roomId: { type: ID, required: true },
            //            speakerId: { type: ID, required: true },
            //            timeSlotId: { type: ID, required: true },
            //            trackId: { type: ID, required: true },

            //            isPartial: { type: BOOL, required: true, isUnmapped: true }
            //        },

            //        // Let model.validation add the requireReferenceEntity validators
            //        navigationProperties: {
            //            room: 'Room',
            //            speaker: 'Person',
            //            timeSlot: 'TimeSlot',
            //            track: 'Track'
            //        }

            //    });
            //}

            //function addRoom() {
            //    addType({
            //        name: 'Room',
            //        dataProperties: {
            //            id: { type: ID },
            //            name: { max: 50, required: true }
            //        }
            //    });
            //}

            //function addTimeSlot() {
            //    addType({
            //        name: 'TimeSlot',
            //        dataProperties: {
            //            id: { type: ID },
            //            start: { type: DATE, required: true },
            //            isSessionSlot: { type: BOOL, required: true },
            //            duration: { type: ID, required: true }
            //        }
            //    });
            //}

            //function addTrack() {
            //    addType({
            //        name: 'Track',
            //        dataProperties: {
            //            id: { type: ID },
            //            name: { max: 50, required: true }
            //        }
            //    });
            //}
        }
    }
} 